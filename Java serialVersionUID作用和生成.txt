Mime-Version: 1.0
Content-Base: file:///D:/Story/index.html
Content-Type: Multipart/related; boundary="NEXT.ITEM-BOUNDARY";type="text/html"

--NEXT.ITEM-BOUNDARY
Content-Type: text/html; charset="utf-8"
Content-Location: file:///D:/Story/index.html

<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>

</style>
</head>
<body>
	<div class="preview"><h1 id="e5ba8fe58897e58c96e5928ce58f8de5ba8fe58897e58c96" name="e5ba8fe58897e58c96e5928ce58f8de5ba8fe58897e58c96"><a name="e5ba8fe58897e58c96e5928ce58f8de5ba8fe58897e58c96" class="blank_anchor_name"></a>序列化和反序列化</h1>
<p>Java是面向对象的语言，与其他语言进行交互（比如与前端js进行http通信），需要把对象转化成一种通用的格式。<br>
比如json（前端显然不认识Java对象），从对象到json字符串的转换，就是序列化的过程，反过来，从json字符串<br>
转换成Java对象，就是反序列化的过程。</p>
<hr>
<h1 id="serialversionuide698afe4bb80e4b988efbc9f" name="serialversionuide698afe4bb80e4b988efbc9f"><a name="serialversionuide698afe4bb80e4b988efbc9f" class="blank_anchor_name"></a>serialVersionUID是什么？</h1>
<p>反序列化的过程，需要从一个json字符串生成一个Java对象。典型的如下：</p>
<p>Gson gson = new Gson();<br>
Request req = gson.fromJson("request string", Request.class)</p>
<p>这时候会有问题，需要验证输入的json字符串是否是从当前的Request这个类序列化过去的，serialVersionUID就是用来干这个的。<br>
当序列化的时候的serialVersionUID与反序列化的时候的serialVersionUID不一致的时候，会跑出InvalidCalssException。<br>
如果没有显式地定义一个serialVersionUID，那么Java会默认根据类信息计算一个serivalVersionUID出来。</p>
<hr>
<h1 id="e5a682e4bd95e7949fe68890" name="e5a682e4bd95e7949fe68890"><a name="e5a682e4bd95e7949fe68890" class="blank_anchor_name"></a>如何生成</h1>
<p>Android Studio可以自动为serializable的类生成一个serialVersionUID。<br>
Settings - Editor - Inspections - Serializable class without ‘serialVersionUID’ 勾选<br>
- 'serialVersionUID' field not declared 'private static final long' 勾选。<br>
这样在没有serialVersionUID的类中，可以自动根据提示生成serialVersionUID了。</p>
<hr>
</div>
</body></html>
--NEXT.ITEM-BOUNDARY--